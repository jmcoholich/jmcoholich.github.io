<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Wowchemy 5.5.0 for Hugo"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap" media=print onload='this.media="all"'><meta name=author content="Jeremiah Coholich"><meta name=description content="Update 9/15/2022: Experimental results coming soon!
When I first started studying reinforcement learning (RL), I implemented Proximal Policy Optimization (PPO) from scratch using only the psuedocode on OpenAI&rsquo;s website. It didn&rsquo;t work and failed to obtain nearly any reward on most OpenAI Gym environments."><link rel=alternate hreflang=en-us href=https://jmcoholich.github.io/post/rl_bag_of_tricks/><meta name=theme-color content="#1565c0"><script src=/js/mathjax-config.js></script>
<link rel=stylesheet href=/css/vendor-bundle.min.c7b8d9abd591ba2253ea42747e3ac3f5.css media=print onload='this.media="all"'><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css integrity="sha512-W0xM4mr6dEP9nREo7Z9z+9X70wytKvMGeDsj7ps2+xg5QPrEBXC8tAW1IFnzjR6eoJ90JmCnFzerQJTLzIEHjA==" crossorigin=anonymous media=print onload='this.media="all"'><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.2.1/build/styles/github.min.css crossorigin=anonymous title=hl-light media=print onload='this.media="all"'><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.2.1/build/styles/dracula.min.css crossorigin=anonymous title=hl-dark media=print onload='this.media="all"' disabled><script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js integrity crossorigin=anonymous async></script>
<link rel=stylesheet href=/css/wowchemy.95d53890c5839471cef2375b6c449b9f.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-QYSG8SXEWT"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}function trackOutboundLink(e,t){gtag("event","click",{event_category:"outbound",event_label:e,transport_type:"beacon",event_callback:function(){t!=="_blank"&&(document.location=e)}}),console.debug("Outbound link clicked: "+e)}function onClickCallback(e){if(e.target.tagName!=="A"||e.target.host===window.location.host)return;trackOutboundLink(e.target,e.target.getAttribute("target"))}gtag("js",new Date),gtag("config","G-QYSG8SXEWT",{}),gtag("set",{cookie_flags:"SameSite=None;Secure"}),document.addEventListener("click",onClickCallback,!1)</script><link rel=manifest href=/manifest.webmanifest><link rel=icon type=image/png href=/media/icon_huc310f1ac1642ff51805cd109dc789c7d_32737_32x32_fill_lanczos_center_3.png><link rel=apple-touch-icon type=image/png href=/media/icon_huc310f1ac1642ff51805cd109dc789c7d_32737_180x180_fill_lanczos_center_3.png><link rel=canonical href=https://jmcoholich.github.io/post/rl_bag_of_tricks/><meta property="twitter:card" content="summary_large_image"><meta property="og:site_name" content="Jeremiah Coholich"><meta property="og:url" content="https://jmcoholich.github.io/post/rl_bag_of_tricks/"><meta property="og:title" content="A Bag of Tricks for Deep Reinforcement Learning | Jeremiah Coholich"><meta property="og:description" content="Update 9/15/2022: Experimental results coming soon!
When I first started studying reinforcement learning (RL), I implemented Proximal Policy Optimization (PPO) from scratch using only the psuedocode on OpenAI&rsquo;s website. It didn&rsquo;t work and failed to obtain nearly any reward on most OpenAI Gym environments."><meta property="og:image" content="https://jmcoholich.github.io/post/rl_bag_of_tricks/featured.png"><meta property="twitter:image" content="https://jmcoholich.github.io/post/rl_bag_of_tricks/featured.png"><meta property="og:locale" content="en-us"><meta property="article:published_time" content="2022-05-31T00:00:00+00:00"><meta property="article:modified_time" content="2022-05-31T00:00:00+00:00"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://jmcoholich.github.io/post/rl_bag_of_tricks/"},"headline":"A Bag of Tricks for Deep Reinforcement Learning","image":["https://jmcoholich.github.io/post/rl_bag_of_tricks/featured.png"],"datePublished":"2022-05-31T00:00:00Z","dateModified":"2022-05-31T00:00:00Z","author":{"@type":"Person","name":"Jeremiah Coholich"},"publisher":{"@type":"Organization","name":"Jeremiah Coholich","logo":{"@type":"ImageObject","url":"https://jmcoholich.github.io/media/icon_huc310f1ac1642ff51805cd109dc789c7d_32737_192x192_fill_lanczos_center_3.png"}},"description":"Update 9/15/2022: Experimental results coming soon!\nWhen I first started studying reinforcement learning (RL), I implemented Proximal Policy Optimization (PPO) from scratch using only the psuedocode on OpenAI\u0026rsquo;s website. It didn\u0026rsquo;t work and failed to obtain nearly any reward on most OpenAI Gym environments."}</script><title>A Bag of Tricks for Deep Reinforcement Learning | Jeremiah Coholich</title></head><body id=top data-spy=scroll data-offset=70 data-target=#TableOfContents class=page-wrapper data-wc-page-id=a720526db105fcb3d60fe9fbb213b85a><script src=/js/wowchemy-init.min.2ed908358299dd7ab553faae685c746c.js></script><aside class=search-modal id=search><div class=container><section class=search-header><div class="row no-gutters justify-content-between mb-3"><div class=col-6><h1>Search</h1></div><div class="col-6 col-search-close"><a class=js-search href=# aria-label=Close><i class="fas fa-times-circle text-muted" aria-hidden=true></i></a></div></div><div id=search-box><input name=q id=search-query placeholder=Search... autocapitalize=off autocomplete=off autocorrect=off spellcheck=false type=search class=form-control aria-label=Search...></div></section><section class=section-search-results><div id=search-hits></div></section></div></aside><div class=page-header><header class=header--fixed><nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id=navbar-main><div class=container-xl><div class="d-none d-lg-inline-flex"><a class=navbar-brand href=/>Jeremiah Coholich</a></div><button type=button class=navbar-toggler data-toggle=collapse data-target=#navbar-content aria-controls=navbar-content aria-expanded=false aria-label="Toggle navigation">
<span><i class="fas fa-bars"></i></span></button><div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none"><a class=navbar-brand href=/>Jeremiah Coholich</a></div><div class="navbar-collapse main-menu-item collapse justify-content-start" id=navbar-content><ul class="navbar-nav d-md-inline-flex"><li class=nav-item><a class=nav-link href=/#about><span>Home</span></a></li><li class=nav-item><a class=nav-link href=/#publications><span>Publications</span></a></li><li class=nav-item><a class=nav-link href=/#awards><span>Awards</span></a></li><li class=nav-item><a class=nav-link href=/#posts><span>Blog</span></a></li></ul></div><ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2"><li class="nav-item dropdown theme-dropdown"><a href=# class=nav-link data-toggle=dropdown aria-haspopup=true aria-label="Display preferences"><i class="fas fa-moon" aria-hidden=true></i></a><div class=dropdown-menu><a href=# class="dropdown-item js-set-theme-light"><span>Light</span></a>
<a href=# class="dropdown-item js-set-theme-dark"><span>Dark</span></a>
<a href=# class="dropdown-item js-set-theme-auto"><span>Automatic</span></a></div></li></ul></div></nav></header></div><div class=page-body><article class=article><div class="article-container pt-3"><h1>A Bag of Tricks for Deep Reinforcement Learning</h1><div class=article-metadata><div><span class=author-highlighted>Jeremiah Coholich</span></div><span class=article-date>May 31, 2022</span>
<span class=middot-divider></span>
<span class=article-reading-time>16 min read</span></div></div><div class="article-header container featured-image-wrapper mt-4 mb-4" style=max-width:1200px;max-height:803px><div style=position:relative><img src=/post/rl_bag_of_tricks/featured_hu601c9f480be93834cf7280d8bffbd671_457153_1200x2500_fit_q75_h2_lanczos_3.webp width=1200 height=803 alt class=featured-image>
<span class=article-header-caption>The KUKA bin environment visualized in NVIDIA IsaacGym</span></div></div><div class=article-container><div class=article-style><p><em>Update 9/15/2022: Experimental results coming soon!</em></p><p>When I first started studying reinforcement learning (RL), I implemented <a href=https://arxiv.org/abs/1707.06347 target=_blank rel=noopener>Proximal Policy Optimization (PPO)</a> from scratch using only the <a href=https://spinningup.openai.com/en/latest/algorithms/ppo.html#pseudocode target=_blank rel=noopener>psuedocode</a> on OpenAI&rsquo;s website. It didn&rsquo;t work and failed to obtain nearly any reward on most OpenAI Gym environments. It took a few more months of debugging, reading other RL implementations, and talking to colleagues to get things working. My conversations with other Georgia Tech students revealed that initially struggling to do basic things with RL was not uncommon. <a href="https://www.alexirpan.com/2018/02/14/rl-hard.html#:~:text=Often%2C%20it%20doesn%27t%2C,out%20of%20the%20RL%20algorithm." target=_blank rel=noopener>These</a> blog <a href=https://andyljones.com/posts/rl-debugging.html target=_blank rel=noopener>posts</a> do a great job of explaining the difficulty with RL and really resonate with my own experiences.</p><p>In hindsight, there was no single major flaw with my initial PPO implementation, but rather many small tricks and optimizations that were missing. The purpose of this post is to enumerate these tricks and provide references to code where they are implemented. They are roughly ordered in descending order of importance. Knowledge of some of these tricks is only necessary if you are implementing an RL algorithm from scratch, as most public implementations will already include them. However, knowing of their existence will enable you to debug more effectively and make changes more intelligently.</p><p>Different RL implementations will include a slightly different set of tricks. As evidence of their importance, check out this figure (below) from the paper <a href=https://arxiv.org/pdf/1709.06560.pdf target=_blank rel=noopener>Deep Reinforcement Learning that Matters</a>. The authors show empirically that different popular implementions of the same RL algorithm differ significantly in performance on standard RL benchmarks, even when controlling for hyperparameters and network architecture.</p><p><img src=fig_6_drl_that_matters.png width=75%><p><em>Figure 6 from <a href=https://arxiv.org/pdf/1709.06560.pdf target=_blank rel=noopener>Deep Reinforcement Learning that Matters</a>, plotting the performance of different RL implementations averaged over 5 random seeds. These variations can be explained by differences in implementation and different PyTorch/TF versions.</em></p></p><p>Now for some disclaimers &ndash; nearly all of my experience comes from training on-policy algorithms for continuous control, so there may be useful tips for discrete/off-policy settings that I&rsquo;m missing. Also, RL is a super-hot field and perhaps some of the content in this post is already outdated. Hopefully, this blog is at least useful to someone starting out like I was. Please don&rsquo;t hesitate to reach out to me if you think there is something important missing!</p><p>Most of the examples will come from either of these two RL implementations:</p><ul><li><a href=https://github.com/ikostrikov/pytorch-a2c-ppo-acktr-gail target=_blank rel=noopener>pytorch-a2c-ppo-acktr-gail</a></li><li><a href=https://github.com/Denys88/rl_games target=_blank rel=noopener>RL Games</a></li></ul><p>Implementing an RL algorithm from scratch is an excellent way to learn. However, if you just need to get something working quickly, you should instead just fork a popular repo and start from there. Here are some suggestions:</p><ul><li><a href=https://stable-baselines3.readthedocs.io/en/master/ target=_blank rel=noopener>Stable Baselines3</a></li><li><a href=https://github.com/Denys88/rl_games target=_blank rel=noopener>RL Games</a></li><li><a href=https://github.com/ikostrikov/pytorch-a2c-ppo-acktr-gail target=_blank rel=noopener>pytorch-a2c-ppo-acktr</a></li><li><a href=https://docs.ray.io/en/latest/rllib/index.html target=_blank rel=noopener>RLlib</a></li></ul><p>Contents:</p><ul><li><a href=#observation-normalization-and-clipping>Observation and Normalization Clipping</a></li><li><a href=#dense-rewards>Dense Rewards</a></li><li><a href=#hyperparameter-tuning>Hyperparameter Tuning</a></li><li><a href=#gradient-normalization-and-clipping>Gradient Normalization and Clipping</a></li><li><a href=#reward-normalization-and-clipping>Reward Normalization and Clipping</a></li><li><a href=#advantage-standardization>Advantage Standardization</a></li><li><a href=#bootstrapping-incomplete-episodes>Bootstrapping Incomplete Episodes</a></li><li><a href=#generalized-advantage-estimation>Generalized Advantage Estimation</a></li><li><a href=#entropy-decay>Entropy Decay</a></li><li><a href=#value-network-loss-clipping>Value Network Loss Clipping</a></li><li><a href=#learning-rate-scheduling>Learning Rate Scheduling</a></li></ul><p>Thanks to <a href=https://www.andrewszot.com/ target=_blank rel=noopener>Andrew Szot</a> and <a href=https://www.linkedin.com/in/mathew-piotrowicz-aa4962137/ target=_blank rel=noopener>Mathew Piotrowicz</a> for reading drafts of this and providing feedback.</p><h3 id=observation-normalization-and-clipping>Observation Normalization and Clipping</h3><p>In RL, the inputs to the policy and value networks are observations, which can consist of values that differ by orders of magnitude. For example, if you are learning a policy to control a robot, your observation could contain joint angles ranging from $ -\frac{\pi}{2} $ to $ \frac{\pi}{2} $ radians and a robot position coordinate that lies between 0 and 1000 meters. Normalizing the input space to eliminate this difference in scale leads to more stable training and faster convergence. This should be nothing new to those with prior experience training neural networks.</p><p>The two most common methods for preprocessing are standardization and rescaling. Standardization refers to subtracting the mean and dividing by the standard deviation of the data so that each dimension approximates a standard normal distribution. Rescaling means mapping the data to the range $ \left[0, 1\right] $ by subtacting the min and dividing by the range. In either case, clipping should also be applied after normalization. Neural networks are bad at extrapolation, and outliers can produce unexpected outputs. In my work, observations are clipped to $[-5.0, 5.0]$ after standardization.</p><p>In supervised learning, statistics calculated over the training set are used to normalize each sample. In RL, this isn&rsquo;t possible because the dataset (consisting of interactions with the environment) is collected online and the statistics change continuously. Because of this, you need to calculate an online mean and standard deviation. Most RL codebases use an implementation of <a href=https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Welford%27s_online_algorithm target=_blank rel=noopener>Welford&rsquo;s Online Algorithm</a> like <a href=https://github.com/DLR-RM/stable-baselines3/blob/master/stable_baselines3/common/running_mean_std.py target=_blank rel=noopener>this one</a> from Stable Baselines3.</p><p>This online approach is best when your algorithm needs to work on many different environments. However, it often causes an initial drop in performance (red circle below) as the mean and standard deviation move rapidly early in training due a small sample size and exploration.</p><p><figure><div class="d-flex justify-content-center"><div class=w-100><img alt=pic srcset="/post/rl_bag_of_tricks/obs_norm_dip_hu981de4d7338294a9cd2c2fae25e4020c_71749_cb7351224d24cbd48db808cd6bb44e05.webp 400w,
/post/rl_bag_of_tricks/obs_norm_dip_hu981de4d7338294a9cd2c2fae25e4020c_71749_f3c994e5b8222cfd49a9dd4f22fd932e.webp 760w,
/post/rl_bag_of_tricks/obs_norm_dip_hu981de4d7338294a9cd2c2fae25e4020c_71749_1200x1200_fit_q75_h2_lanczos_3.webp 1200w" src=/post/rl_bag_of_tricks/obs_norm_dip_hu981de4d7338294a9cd2c2fae25e4020c_71749_cb7351224d24cbd48db808cd6bb44e05.webp width=760 height=380 loading=lazy data-zoomable></div></div></figure><em>An initial drop in performance caused by normalization statistics moving faster than the policy updates.</em></p><p>Alternatively, if you have good prior knowledge about the bounds of the observation space, you can just rescale your data to the range [-1, 1] or [0, 1], like what they do <a href=https://github.com/leggedrobotics/legged_gym/blob/dd6a6892e54c4f111a203319c05da8dca9595ae1/legged_gym/envs/base/legged_robot.py#L212 target=_blank rel=noopener>here</a>.</p><p><strong>Note:</strong> A common bug when replaying trained policies is the failure to save and load normalization statistics. A policy network will not work during test time if the inputs are not preprocessed the same way they were during training.</p><p>Code examples</p><ul><li><a href=https://github.com/Denys88/rl_games/blob/06a3319d3a6af566d984aa5953b1fd7a24a8e3a4/rl_games/common/a2c_common.py#L587 target=_blank rel=noopener>RL Games 1</a></li><li><a href=https://github.com/Denys88/rl_games/blob/94e55563be60f10e659428cdce7b4e0bd131d471/rl_games/algos_torch/models.py#L41 target=_blank rel=noopener>RL Games 2</a></li><li><a href=https://github.com/ikostrikov/pytorch-a2c-ppo-acktr-gail/blob/41332b78dfb50321c29bade65f9d244387f68a60/a2c_ppo_acktr/envs.py#L193 target=_blank rel=noopener>pytorch-a2c-ppo-acktr-gail</a></li></ul><h3 id=dense-rewards>Dense Rewards</h3><p>This tip will only be applicable if you are applying RL to a new task where you have the freedom to specify a reward function, rather than training on standard RL benchmarks where the reward function is part of the task.</p><p>Sparse rewards are difficult for RL algorithms to learn from. If possible, try making your reward <em>dense</em>, meaning that at every timestep the agent recieves an informantive reward as a function of the current state, previous state, and action taken. For example, instead of rewarding an agent +1.0 for reaching a goal and 0.0 otherwise, try giving a reward at every timestep that is propotional to progress towards the goal. Of course, this requires some prior knowledge of what progress looks like and can limit the types of solutions that your policy discovers.</p><p><img src=allsteps.png width=50%><p><em>Figure 3 from <a href=https://arxiv.org/abs/2005.04323 target=_blank rel=noopener>ALLSTEPS: Curriculum-driven Learning of Stepping Stone Skills</a> depicting the stepping-stone task</em></p></p><p>For example, in the paper <a href=https://arxiv.org/abs/2005.04323 target=_blank rel=noopener>ALLSTEPS: Curriculum-driven Learning of Stepping Stone Skills</a>, the authors train a bipedal robot to hit a series of stepping stones. A naive reward design would give +1.0 if the robot&rsquo;s foot hit the center of the foot target (depicted above), and 0.0 otherwise. Instead of doing this, the authors specify a reward function of</p><p>$$ r_{target} = k_{target}\exp(-d/k_d) $$</p><p>where $d$ is the distance from the foot to the target, and $ k_{target}$ and $k_d$ are hyperparameters. If the robot&rsquo;s foot makes any contact with the stepping stone, it receives a reward. The closer the foot is to the center of the block, the higher the reward. The authors explain:</p><blockquote><p>In the initial stages of training, when the character makes contact with the target, the contact location may be far away from the center. Consequently, the gradient with respect to the target reward is large due to the exponential, which encourages the policy to move the foot closer to the center in the subsequent training iterations.</p></blockquote><p>Without the dense reward, there would be no reward gradient across the state space, which makes learning more difficult.</p><h3 id=hyperparameter-tuning>Hyperparameter Tuning</h3><p>RL is notoriously sensitive to hyperparameters and there is no one-size-fits-all for good hyperparameter values. Typically, different implementations and different applications will require different hyperparameters. Here are just a few hyperparameters that could make a difference:</p><ul><li>reward function term coefficients</li><li>number of policy updates and samples per update</li><li>learning rate</li><li>entropy coefficient</li><li>value coefficient</li><li>network architecture</li><li>batch size and number of epochs per policy update</li><li>clipping values for gradients, rewards, values, observations, and the PPO loss</li></ul><p>The good thing is <a href=https://docs.wandb.ai/guides/sweeps target=_blank rel=noopener>Weights & Biases</a> has a powerful pipeline for automated, distributed hyperparameter sweeps. They support random search, grid search, and Bayesian search.</p><h3 id=gradient-normalization-and-clipping>Gradient Normalization and Clipping</h3><p>This is another one that could be obvious if you have a background in deep learning already. Normalizing the gradient of the value and policy networks after each backward pass can help avoid numerical overflow, exploding gradients, or destructively large parameter updates. Other tricks for avoiding these same issues include reward normalization and clipping, value function loss clipping, and advantage standardization.</p><p>Code examples:</p><ul><li><a href=https://github.com/Denys88/rl_games/blob/8da6852f72bdbe867bf12f792b00df944b419c43/rl_games/common/a2c_common.py#L252 target=_blank rel=noopener>RL Games</a></li><li><a href=https://github.com/ikostrikov/pytorch-a2c-ppo-acktr-gail/blob/efc71f600a2dca38e188f18ca85b654b37efd9d2/a2c_ppo_acktr/algo/ppo.py#L82 target=_blank rel=noopener>pytorch-a2c-ppo-acktr-gail</a></li><li><a href=https://pytorch.org/docs/stable/generated/torch.nn.utils.clip_grad_norm_.html target=_blank rel=noopener>torch.nn.utils.clip_grad_norm_</a></li><li><a href=https://pytorch.org/docs/stable/generated/torch.nn.utils.clip_grad_value_.html target=_blank rel=noopener>torch.nn.utils.clip_grad_value_</a></li></ul><h3 id=reward-normalization-and-clipping>Reward Normalization and Clipping</h3><p>Typically, it is best not to have reward values that differ by many orders of magnitude. For example, in the paper <a href=https://www.cs.toronto.edu/~vmnih/docs/dqn.pdf target=_blank rel=noopener>Playing Atari with Deep Reinforcement Learning</a>, the authors clip all rewards to the range $ \left[-1, 1\right] $.</p><blockquote><p>Since the scale of scores varies greatly from game to game, we fixed all positive rewards to be 1 and all negative rewards to be −1, leaving 0 rewards unchanged. Clipping the rewards in this manner limits the scale of the error derivatives and makes it easier to use the same learning rate across multiple games. At the same time, it could affect the performance of our agent since it cannot differentiate between rewards of different magnitude.<br>&ndash; <cite>Mnih, Volodymyr, Koray Kavukcuoglu, David Silver, Alex Graves, Ioannis Antonoglou, Daan Wierstra, and Martin Riedmiller. &ldquo;Playing atari with deep reinforcement learning.&rdquo; arXiv preprint arXiv:1312.5602 (2013).</cite></p></blockquote><p>In addition to just clipping the rewards, you can also keep a running mean and standard deviations of rewards to standardize rewards or returns (discounted rewards).</p><p>Code examples:</p><ul><li><a href=https://github.com/ikostrikov/pytorch-a2c-ppo-acktr-gail/blob/efc71f600a2dca38e188f18ca85b654b37efd9d2/a2c_ppo_acktr/model.py target=_blank rel=noopener>pytorch-a2c-ppo-acktr-gail</a><ul><li>Rewards are processed by these two environment wrappers from Stable Baselines3</li><li><a href=https://stable-baselines3.readthedocs.io/en/master/common/atari_wrappers.html#stable_baselines3.common.atari_wrappers.ClipRewardEnv target=_blank rel=noopener>stable_baselines3.common.atari_wrappers.ClipRewardEnv</a></li><li><a href=https://stable-baselines3.readthedocs.io/en/master/guide/vec_envs.html#stable_baselines3.common.vec_env.VecNormalize.normalize_reward target=_blank rel=noopener>stable_baselines3.common.vec_env.VecNormalize.normalize_reward</a></li></ul></li></ul><h3 id=advantage-standardization>Advantage Standardization</h3><p>Before calculating a loss for the policy network, advantages are computed and then standardized, such that about half of the advantages are positive and about half are negative. This is done for stability of training and variance reduction. Here is an excerpt from <a href=http://rail.eecs.berkeley.edu/deeprlcourse-fa17/f17docs/hw2_final.pdf target=_blank rel=noopener>HW2</a> of the Berkely Deep RL course:</p><blockquote><p>A trick which is known to usually boost empirical performance by lowering variance of the
estimator is to center advantages and normalize them to have mean of 0 and a standard
deviation of 1.
From a theoretical perspective, this does two things:</p><ul><li>Makes use of a constant baseline at all timesteps for all trajectories, which does not
change the policy gradient in expectation.</li><li>Rescales the learning rate by a factor of 1/σ, where σ is the standard dev of the
empirical advantages.</li></ul></blockquote><p>Code Examples</p><ul><li><a href=https://github.com/ikostrikov/pytorch-a2c-ppo-acktr-gail/blob/41332b78dfb50321c29bade65f9d244387f68a60/a2c_ppo_acktr/algo/ppo.py#L36 target=_blank rel=noopener>pytorch-a2c-ppo-acktr-gail</a></li><li><a href=https://github.com/Denys88/rl_games/blob/7b5f9500ee65ae0832a7d8613b019c333ecd932c/rl_games/common/a2c_common.py#L857 target=_blank rel=noopener>RL Games</a></li></ul><h3 id=bootstrapping-incomplete-episodes>Bootstrapping Incomplete Episodes</h3><p>In most RL pipelines, the environment runs for a pre-specified number of steps before a policy update occurs. This means the sample collection will often end before the episode does, meaning the policy will be updated with samples from incomplete episodes. When returns (sum of discounted future rewards) are calculated, this truncation makes it seem as if the agent received zero reward for the rest of the episode. To correct this error, the return computation can be &ldquo;bootstrapped&rdquo; with the value estimate of the final state.</p><p>The dictionary definition of bootstrap:</p><blockquote><p><strong>Bootstrap (verb)</strong></p><ol><li>get (oneself or something) into or out of a situation using existing resources.<br>&ldquo;the company is bootstrapping itself out of a marred financial past&rdquo;<br></li></ol><p>Source: <a href=https://languages.oup.com/google-dictionary-en/ target=_blank rel=noopener>OxfordLanguages</a></p></blockquote><p>In the context of RL, bootstrapping means estimating value function or Q-function targets using estimates from the same value or Q-function (&ldquo;existing resources&rdquo;). Bootstrapping is done with every sample in <a href=https://en.wikipedia.org/wiki/Temporal_difference_learning target=_blank rel=noopener>temporal difference learning</a> (TD-learning) and Q-learning. In TD learning, the value estimates are :</p><p>$$\hat{V}(s_0) = r_0 + \gamma V(s_{1})$$</p>At the other end of the spectrum, values can be estimated for a state $s_0$ without bootstrapping using complete trajectories that start at $s_0$. The value estimate for a state $ s_0 $ from a single rollout from $s_0$ to $s_H$ is:<p>$$ \hat{V}(s_0) = \sum_{t = 0}^{H}\gamma^t r_t $$</p><p>When the episode gets truncated at $ h &lt; H $, we can bootstrap this calculation using the value estimate of the final state. Note how $r_h$ is discarded and replaced with $V(s_h)$.</p><p>$$ \hat{V}(s_0) = \sum_{t = 0}^{h - 1}\gamma^t r_t + \gamma^{h}V(s_{h}) $$</p><p>Bootstrapping can help, but it can also hurt. It reduces variance in the computation of returns at the expense of introducing a bias from the value network. Here are some excerpts from Sutton and Barto&rsquo;s textbook, where they place bootstrapping in the &ldquo;Deadly Triad&rdquo; of instability and divergence.</p><blockquote><p>&mldr;bootstrapping methods using function approximation may actually diverge to infinity.
&mldr;Bootstrapping often results in faster learning because it allows learning to take advantage of the state property, the ability to recognize a state upon returning to it. On the other hand, bootstrapping can impair learning on problems where the state representation is poor and causes poor generalization.<br>&ndash; <cite><a href=https://www.andrew.cmu.edu/course/10-703/textbook/BartoSutton.pdf target=_blank rel=noopener>Barto, Sutton. Reinforcement Learning: An Introduction. 2018</a></cite></p></blockquote><p>Controlling this bias-variance tradeoff with bootstrapping is a central idea in <a href=#generalized-advantage-estimation>Generalized Advantage Estimation (GAE)</a>.</p><p>This kind of bootstrapping should also be applied to timeout terminations on continouous tasks. Continuous tasks are those where episodes do not end once a particular objective is achieved. One example of this is robot locomotion, where success could be foward walking that continues indefinitely. However, in order to increase sample diversity, episodes are typically subject to a timeout. Since the timeout is independent of the robot&rsquo;s performance, the returns should be bootstrapped.</p><p>Code examples:</p><ul><li><a href=https://github.com/ikostrikov/pytorch-a2c-ppo-acktr-gail/blob/efc71f600a2dca38e188f18ca85b654b37efd9d2/a2c_ppo_acktr/storage.py#L86 target=_blank rel=noopener>pytorch-a2c-ppo-acktr-gail</a><ul><li>In this computation, the tensor <code>self.bad_masks</code> indicates when bootstrapping should occur. If its value is 0, then the reward at the terminal timestep is replaced with the value estimate of the terminal state.</li></ul></li></ul><h3 id=generalized-advantage-estimation>Generalized Advantage Estimation</h3><p>Generalized Advantage Estimation (GAE), from the paper from the paper <a href=https://arxiv.org/pdf/1506.02438.pdf target=_blank rel=noopener>High-Dimensional Continuous Control Using Generalized Advantage Estimation</a>, provides a continuous bias-variance tradeoff through controlling the amount of bootstrapping via a parameter $\lambda$. The formula for computing advantages is given below, but I highly recommend reading the actual paper if you are going to program this yourself.</p>$$ \hat{A}^{GAE(\gamma, \lambda)}_t = \sum^\infty_{l=0} (\gamma \lambda)^l \delta^V_{t+l} $$
$$\delta_{t}^V = r_t + \gamma V(s_{t+1}) -V(s_t)$$<p>The TD-learning value update is a special case of GAE when $\lambda = 0$. When $\lambda = 1$, no bootstrapping occurs. Most of the time, I set $\gamma = 0.99$ and $\lambda = 0.95$.</p><p>The above two equations from the paper deal with the infinite time horizon case. Dealing with terminations and bootstrapping in the finite-horizon case can be confusing, so I&rsquo;ve provided some equations below. Again, assume these are estimates of advantages and values from a single trajectory from $s_0$ to $s_H$ where truncation occurs at timestep $h &lt; H$.</p><p><strong>Finite time horizon, no bootstrapping (full episode)</strong><br>Note that $\delta_H$ becomes $r_H - V(s_H)$ because $V(s_{H+1})$ is zero.<br></p><p>$$\hat{A}^{GAE(\gamma, \lambda)}_t= \sum_{t=0}^{H-1} (\gamma \lambda)^t \delta^t + (\gamma \lambda)^H (r_H - V(s_H))$$
$$\hat{V}^{GAE(\gamma, \lambda)}_t= \hat{A}^{GAE(\gamma, \lambda)}_t + V(s_o)$$</p><br><p><strong>Finite time horizon with bootstrapping</strong><br>Note that $r_h$ is replaced with $V(s_h)$, which makes the final term zero.</p><p>$$\hat{A}^{GAE(\gamma, \lambda)}_t= \sum_{t=0}^{h-1} (\gamma \lambda)^t \delta^t $$
$$\hat{V}^{GAE(\gamma, \lambda)}_t= \hat{A}^{GAE(\gamma, \lambda)}_t + V(s_o)$$</p><p>Code examples:</p><ul><li><a href=https://github.com/ikostrikov/pytorch-a2c-ppo-acktr-gail/blob/efc71f600a2dca38e188f18ca85b654b37efd9d2/a2c_ppo_acktr/storage.py#L73 target=_blank rel=noopener>pytorch-a2c-ppo-acktr-gail</a></li><li><a href=https://github.com/Denys88/rl_games/blob/d6ccfa59c85865bc04d80ca56b3b0276fec82f90/rl_games/common/a2c_common.py#L474 target=_blank rel=noopener>RL Games</a><ul><li>As far as I can tell, RL Games does not do any bootstrapping of truncated episodes or timeouts. No information about the nature of terminations is received from the environment, and there is no condition where the advantage of a timestep is set to zero.</li></ul></li></ul><h3 id=entropy-decay>Entropy Decay</h3><p>The exploration-exploitation tradeoff is a fundamental problem in RL which is usually dealt with through experimentation or hyperparamter tuning. Generally, you want more exploration early in training. The most basic way to increase exploration is to increase the entropy of the policy used to obtain environment samples. Assuming the policy outputs to a Gaussian distribution over actions, the entropy is proportional to the log of the variance. In on-policy algorithms like TRPO and PPO, entropy can be controlled indirectly via a loss term that reward entropy. In off-policy algorithms like DDPG, SAC, or TD3, noise is added to the output of a deterministic policy during sample collection. The entropy of the sampling process can be directly controlled via this noise. Starting with a high entropy coefficient/high-variance noise and decaying the desired entropy to zero may yield the desired exploration-exploitation behavior.</p><p>In my own work in legged locomotion, I have often found this uncessary. The majority of the time, I use PPO and set the entropy coefficient to 0.0 for the entirety of training. Perhaps the chaotic underactuated dynamics of the legged robot eliminates the need for extra exploration noise.</p><p>Code example:</p><ul><li><a href=https://github.com/Denys88/rl_games/blob/7b5f9500ee65ae0832a7d8613b019c333ecd932c/rl_games/common/schedulers.py#L54 target=_blank rel=noopener>RL Games</a></li></ul><h3 id=value-network-loss-clipping>Value Network Loss Clipping</h3><p>This is another trick aimed at controlling the behavior of the gradients and preventing excessively large updates. The value function is trained on a mean-squared error (MSE) loss where the target values are value estimates from policy rollouts. This is contrast to supervised learning, where the targets are stationary ground-truth labels. Because the targets themselves are estimates derived from a stochastic sampling process, inaccurate targets which produce large errors can occur.</p><p>Value network loss clipping roughly constrains the change in value estimates between policy iterations to a &ldquo;trust region&rdquo; of $\pm\ \epsilon$ from the old value estimates. (Constraining updates to a trust region is the central idea behind TRPO and PPO, but for action probabilities instead of value estimates.) The loss calculation is given below, where backpropogation happens through $V_{new}(s_0)$ only.</p>$$ V_{clip}(s_0) = V_{old}(s_0) + \text{Clip}(V_{new}(s_0) - V_{old}(s_0),\ - \epsilon,\ \epsilon) $$
$$\mathcal{L}_{\text{MSE-Clip}} = (V_{clip}(s_0) - V_{target}(s_0))^2 $$
$$\mathcal{L}_{\text{MSE}} = (V_{new}(s_0) - V_{target}(s_0))^2 $$
$$\mathcal{L}_{\text{final}} = \text{max}(\mathcal{L}_{\text{MSE-Clip}}, \mathcal{L}_{\text{MSE}})$$<p>$\epsilon$ is usually set to something like $0.2$. Note that $V_{new}(s_0)$ could end up slightly outside of $\left[V_{old}(s_0) - \epsilon, V_{old}(s_0) + \epsilon\right]$. This is because the values themselves are not clipped, rather, the updates to the value function stop happening when clipping occurs ($\epsilon$ is just a constant with no dependency on the value network parameters &ndash; no backprop can occur through $\epsilon$). This could also be due to parameter updates from loss terms corresponding to states other than $s_0$.</p><p>Honestly, the clipped value update is rather confusing, especially at first. In my analysis, I discovered an edge case where value updates should occur, but don&rsquo;t (figure below). Moving $V_{new}$ in the direction of $V_{target}$ will move $V_{new}$ closer to the trust region, but this update doesn&rsquo;t occur because the distance from the nearest edge of the trust region to $V_{target}$ is greater than the distance between $V_{target}$ and $V_{new}$. However, perhaps the clipped MSE loss makes it unlikely that $V_{new}$ will end up far outside the trust region in the first place.</p><p><figure><div class="d-flex justify-content-center"><div class=w-100><img src=value_edge_case.svg alt=pic loading=lazy data-zoomable></div></div></figure><em>An edge case in the value network loss clipping trick, where updates to $V_{new}$ in the direction of $V_{old}$ are prevented.</em></p><p>Strangely, I couldn&rsquo;t find much mention of value network loss clipping in the academic literature or on the internet, and I don&rsquo;t know if this technique goes by another name. I only found <a href=https://research.google/pubs/pub50213/ target=_blank rel=noopener>this paper</a> (&ldquo;PPO-style pessimistic clipping&rdquo;) and this <a href=https://github.com/openai/baselines/issues/91 target=_blank rel=noopener>GitHub issue</a>. I don&rsquo;t think &ldquo;pessimistic clipping&rdquo; is an appropriate name, since &ldquo;pessimism&rdquo; in the context of value functions in RL usually means values are underestimated.</p><p>Code Examples:</p><ul><li><a href=https://github.com/Denys88/rl_games/blob/8da6852f72bdbe867bf12f792b00df944b419c43/rl_games/common/common_losses.py#L7 target=_blank rel=noopener>RL Games</a></li><li><a href=https://github.com/ikostrikov/pytorch-a2c-ppo-acktr-gail/blob/41332b78dfb50321c29bade65f9d244387f68a60/a2c_ppo_acktr/algo/ppo.py#L68 target=_blank rel=noopener>pytorch-a2c-ppo-acktr-gail</a></li></ul><h3 id=learning-rate-scheduling>Learning Rate Scheduling</h3><p>A linearly decreasing learning rate is a common technique for training neural networks. The idea is that in the beginning of training, the optimizer should take large steps to minimize loss rapidly, while near the end, the steps should be smaller to facilitate convergence to a local optima.</p><p>A fancier way to control the learning rate is to adaptively set it based on a desired KL-divergence between policy iterations. In most of my work, I use the RL Games implementation of an adaptive learning rate with an initial learning rate of 1e-5. Here is what the learning rate and KL-divergence plots usually looks like:<figure><div class="d-flex justify-content-center"><div class=w-100><img alt=pic srcset="/post/rl_bag_of_tricks/adaptive_lr_hu195bc64329187de28f24674117a3749b_108774_c1d09df98d6fcc1d90dd947d5349c4c8.webp 400w,
/post/rl_bag_of_tricks/adaptive_lr_hu195bc64329187de28f24674117a3749b_108774_b7bf57980ec21268496775759909e319.webp 760w,
/post/rl_bag_of_tricks/adaptive_lr_hu195bc64329187de28f24674117a3749b_108774_1200x1200_fit_q75_h2_lanczos_3.webp 1200w" src=/post/rl_bag_of_tricks/adaptive_lr_hu195bc64329187de28f24674117a3749b_108774_c1d09df98d6fcc1d90dd947d5349c4c8.webp width=760 height=263 loading=lazy data-zoomable></div></div></figure><em>KL-divergence and learning rate plotted for five training runs from my <a href=https://www.jeremiahcoholich.com/publication/quadruped_footsteps/ target=_blank rel=noopener>quadruped project</a>. The desired KL-divergence was set to 0.01. The learning rate hovers around 7e-4.</em></p><p>Code examples for linear learning rate decay:</p><ul><li><a href=https://github.com/ikostrikov/pytorch-a2c-ppo-acktr-gail/blob/efc71f600a2dca38e188f18ca85b654b37efd9d2/a2c_ppo_acktr/utils.py#L46 target=_blank rel=noopener>pytorch-a2c-ppo-acktr-gail</a></li><li><a href=https://pytorch.org/docs/stable/generated/torch.optim.lr_scheduler.StepLR.html target=_blank rel=noopener>torch.optim.lr_scheduler.StepLR</a></li></ul><p>Code for adaptive learning rate:</p><ul><li><a href=https://github.com/Denys88/rl_games/blob/50d9a460f8ba41de5dbac4abed04f8de9b849f4f/rl_games/common/schedulers.py#L19 target=_blank rel=noopener>RL Games</a></li></ul><p>Thanks for reading!</p></div><div class="media author-card content-widget-hr"><a href=https://jmcoholich.github.io><img class="avatar mr-3 avatar-circle" src=/authors/admin/avatar_hu6b7664f523075193f9f11d79c1c9dcfa_924364_270x270_fill_q75_lanczos_center.jpg alt="Jeremiah Coholich"></a><div class=media-body><h5 class=card-title><a href=https://jmcoholich.github.io>Jeremiah Coholich</a></h5><h6 class=card-subtitle>Robotics PhD Student</h6><p class=card-text>My research interests include deep learning, reinforcement learning, and legged robots.</p><ul class=network-icon aria-hidden=true><li><a href=mailto:jcoholich@gatech.edu><i class="fas fa-envelope"></i></a></li><li><a href="https://scholar.google.com/citations?user=KXw8YxAAAAAJ&hl=en&oi=ao" target=_blank rel=noopener><i class="fas fa-graduation-cap"></i></a></li><li><a href=https://github.com/jmcoholich target=_blank rel=noopener><i class="fab fa-github"></i></a></li><li><a href=https://www.linkedin.com/in/jeremiah-coholich/ target=_blank rel=noopener><i class="fab fa-linkedin"></i></a></li><li><a href=/uploads/CV_Fall_2022.pdf><i class="ai ai-cv"></i></a></li></ul></div></div></div></article></div><div class=page-footer><div class=container><footer class=site-footer><p class="powered-by copyright-license-text">© 2022 Jeremiah Coholich</p><p class=powered-by>Published with <a href="https://wowchemy.com/?utm_campaign=poweredby" target=_blank rel=noopener>Wowchemy</a> — the free, <a href=https://github.com/wowchemy/wowchemy-hugo-themes target=_blank rel=noopener>open source</a> website builder that empowers creators.</p></footer></div></div><script src=/js/vendor-bundle.min.d26509351aa0ff874abbee824e982e9b.js></script>
<script src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.2.1/build/highlight.min.js integrity="sha512-Ypjm0o7jOxAd4hpdoppSEN0TQOC19UtPAqD+4s5AlXmUvbmmS/YMxYqAqarQYyxTnB6/rqip9qcxlNB/3U9Wdg==" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.2.1/build/languages/r.min.js crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.2.1/build/languages/latex.min.js crossorigin=anonymous></script>
<script id=search-hit-fuse-template type=text/x-template>
        <div class="search-hit" id="summary-{{key}}">
          <div class="search-hit-content">
            <div class="search-hit-name">
              <a href="{{relpermalink}}">{{title}}</a>
              <div class="article-metadata search-hit-type">{{type}}</div>
              <p class="search-hit-description">{{snippet}}</p>
            </div>
          </div>
        </div>
      </script><script src=https://cdn.jsdelivr.net/gh/krisk/Fuse@v3.2.1/dist/fuse.min.js integrity="sha512-o38bmzBGX+hD3JHWUFCDA09btWaqrNmoJ3RXLlrysA7PP01Kgs4UlE4MhelE1v5dJR3+cxlR4qQlotsW7jKsnw==" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/gh/julmot/mark.js@8.11.1/dist/jquery.mark.min.js integrity="sha512-mhbv5DqBMgrWL+32MmsDOt/OAvqr/cHimk6B8y/bx/xS88MVkYGPiVv2ixKVrkywF2qHplNRUvFsAHUdxZ3Krg==" crossorigin=anonymous></script>
<script id=page-data type=application/json>{"use_headroom":true}</script><script src=/js/wowchemy-headroom.c251366b4128fd5e6b046d4c97a62a51.js type=module></script>
<script src=/en/js/wowchemy.min.43c8f7a4851160885a7d8069dfa86538.js></script><div id=modal class="modal fade" role=dialog><div class=modal-dialog><div class=modal-content><div class=modal-header><h5 class=modal-title>Cite</h5><button type=button class=close data-dismiss=modal aria-label=Close>
<span aria-hidden=true>&#215;</span></button></div><div class=modal-body><pre><code class="tex hljs"></code></pre></div><div class=modal-footer><a class="btn btn-outline-primary my-1 js-copy-cite" href=# target=_blank><i class="fas fa-copy"></i> Copy</a>
<a class="btn btn-outline-primary my-1 js-download-cite" href=# target=_blank><i class="fas fa-download"></i> Download</a><div id=modal-error></div></div></div></div></div><script src=/js/wowchemy-publication.68f8d7090562ca65fc6d3cb3f8f2d2cb.js type=module></script></body></html>